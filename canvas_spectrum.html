<!doctype html><html><head><meta charset=utf-8><title>Spectrum (webapp audio editor) v2.7</title><style>
:root{--bg:#0f1720;--panel:#0b1520;--accent:#2dd4bf;--muted:#fad;--track:#071126;--wave:#1fbfa6;--glass:#fff1;}
body{background:#111;color:#eee;user-select:none;font-family:sans-serif;}   canvas{border:1px solid #444}
header{padding:0 0 .4em 0;border-bottom:1px solid #fff2;}
input{margin:10px}   input[type='file']{opacity:.3}   input[type="range"]{filter:invert(1);opacity:.5;}
.flex{display:flex;} .flex_wrap{flex-wrap:wrap;} .justif_space{justify-content:space-between;} .y_center{align-items:center;}
pre{position:absolute;left:14em;top:-.4em;padding:0;width:13em;opacity:.6;height:1.25em;overflow:hidden;cursor:pointer;color:#4bf;font-size:16px;}
pre.show{left:1em;top:2.4em;width:calc(100vw - 2em);padding:0;text-align:center;opacity:1;background:#1c1c1cee;height:auto;color:#eee;}
button{background:none;border:1px solid #fff3;margin:0 .5em;padding:.4em .77em .52em .8em;border-radius:5px;color:#aaa;cursor:pointer;}
button:hover{border-color:#fff6;color:#fff}

.track{position:relative;background:var(--track);margin-bottom:12px;}

.waveform path{stroke:var(--wave);stroke-width:2;fill:rgba(31,191,166,0.4)}

.minicard{width:9em;min-height:2em;border-radius:5px;background:var(--glass);text-align:center;padding:.5em 0;margin:.5em;border:1px solid #fff2;color:var(--muted);}
.minicard .key{font-size:.88em;color:var(--muted)}
.minicard .value{font-weight:600;color:#fff;font-size:13px;margin-top:4px}

.card{background:#8881;padding:.2em;margin:.4em;border-radius:5px;border:1px solid #ccc2;}
/*

TODO gui, revoir si pics (reperes duration)
TODO gui, wow, idée, on pourrait poser des bandeaux d'info dans la musique juste pour memo ce qu'on a capté ou ce qu'on voudrait faire
TODO wow, idée, muter un canal à l'écoute
TODO selectionner un canal pour l'éditer
TODO pouvoir editer un pixel lorsque move y, et un bouton switch pour éditer plusieurs lorsque move x
TODO un algo pour smooth une selection (genre éviter les variations trop absurde entre deux pixels selon variation d'autour
*/
</style></head><body>

<header class="flex flex_wrap justif_space">
  <div class="flex y_center"><span>Spectrum v1.6</span></div>
  <div>
    <button id="playBtn" title="Play-Pause">▶︎</button>
    <button id="stopBtn" title="Stop">■</button>
    <button id="rwBtn" title="Rewind">◀◀</button>
    <button id="ffBtn" title="Fast Forward">▶▶</button>
	<button id="import_file">Importer audio</button>
	<button id="exportWav">Export (.wav)</button>
	<button id="exportLent">Export (compressé mais lent)</button>
	<button id="btn_add_dura_empty">Ajouter du vide</button>
	<button id="btn_volume">Volume</button>
	<button id="btn_analyse_freq">Analyser 5 secondes</button>
  </div>
</header>


<div class="flex flex_wrap justif_space">

  <div class="card">
    <div class="minicard" title="Titre">
      <div class="key">Titre</div>
      <div class="value">exemple.mp3</div>
    </div>
    <div class="minicard" title="Longueur">
      <div class="key">Longueur</div>
      <div class="value">03:02.001 234</div>
    </div>
    <div class="minicard" title="Canaux">
      <div class="key">Canaux</div>
      <div class="value">Mono</div>
    </div>
  </div>

  <div class="card">
    <div class="minicard" title="Curseur">
      <div class="key">Curseur</div>
      <div class="value">02:21.160 654</div>
    </div>
  </div>

  <div class="card">
    <div class="minicard" title="Lecteur">
      <div class="key">Lecteur</div>
      <div class="value">03:20.120 444</div>
    </div>
    <div class="minicard" title="Selecteur1">
      <div class="key">Selecteur 1</div>
      <div class="value">02:17.160 654</div>
    </div>
    <div class="minicard" title="Selecteur2">
      <div class="key">Selecteur 2</div>
      <div class="value">02:41.160 654</div>
    </div>
  </div>

  <div class="card">
    <h3>Navigation</h3>
	<div class="flex flex_wrap y_center"><div>Zoom</div><div><input type="range" min="-12" max="12" value="0" aria-label="Low"></div></div>
	<div class="flex flex_wrap y_center"><div>Lecteur</div><div><input type="range" min="-12" max="12" value="0" aria-label="Low"></div></div>
	<div><span id="infos"></span></div>
  </div>

</div>

<input id=f type=file accept=audio style="display:none;">
<canvas id=c width=1600 height=600 style="position:absolute;left:calc(50vw - 800px);bottom:1em;"></canvas>
<canvas id=d width=1600 height=600 style="position:absolute;left:calc(50vw - 800px);bottom:1em;"></canvas>

<pre onclick="this.classList.toggle('show');">(mini doc utilisateur)

Spectrum permet d'exporter en wav, un fichier contenant 1 à 2 canaux audio, dont on va éditer le contenu.

> [F11] activer/désactiver le mode plein écran
> [scroll] pour zoomer et dezoomer (avec centrage recalculé)
> [espace] pour écouter 2 secondes (selon position selecteur)
> touches [gauche] et [droite] pour déplacer le lecteur temporaire (et autoplay)
> [clic] pour déplacer le selecteur
> [shift] + [clic] pour selectionner une zone depuis le pointeur 1
> [suppr] dégager la zone selectionnée
> [ctrl] + [C] copier discretement une zone (pixel perfect: chaque pixel entamé sera copié)
> [ctrl] + [V] coller selon position selecteur (pixel perfect: le collage est au début du pixel choisi, sauf si le selecteur dépasse le milieu)
> [ctrl] + [A] selectionner tout
> [debut] simuler un clic en début de fichier (fonctionne avec shift aussi)
> [fin] simuler un clic en fin de fichier (fonctionne avec shift aussi)

+ inserer du vide pendant 1sec (ou selon la zone selectionnée)
/!\ pas de ctrl+z pour le moment, donc faisez gaff hein
ne lisez surtout pas le code source, ça va vous spoil pour la suite xD

analyseur de spectre v1, avec forcage des valeurs faible, mais bon jconnais pas les frequences affichées

80% by msnbrest, 20% (base et aides) créé par www.perplexity.ai :
salut, peux tu coder une mini page html et javascript, css darkmode, en golf code.
le but est d'ouvrir un fichier audio ogg, puis afficher dans un canvas la puissance
du son (un pixel chaque seconde, sans calcul de moyenne), juste une preview rapide.
et en commentaire peux tu décrire en quelques lignes comment aurait du etre
un canvas pour afficher un analyseur de frequence
</pre>

<script>
/*
_menu_

tiny_functions

edit:
e_add_dura_empty
e_volume
e_analyse_freq
e_del_zone
o_selectors
o_clipboard

draw:
d_redraw_onde
d_redraw_overlay
d_draw_spectrum_moy

user:
u_mouse_move
u_mouse_down
u_set_sel1
u_mouse_scroll
u_press_key

wave:
v_load_a_file
d_drawSpectrum
d_colo_by_amp
v_play_now
v_del_mem_player
v_import
v_export
v_conv_to_wav
v_create_wav_header

end_of_functions
*/

// TODO dans Navigation, lorsque scroll alors update auto input
// et lorsque edit human input alors update display zoom
// pareil pour position lecteur.

let _sel= sel=> document.querySelector(sel),
c= _sel("#c"),
d= _sel("#d");

let aa, g_src, awb, sr=48000, meta_in={}, start=0, w=c.width, w2=c.width/2|0, zoom_y=1, zoom_x=30*64,
h=c.height, h25=c.height*0.25|0, h50=c.height*0.5|0, h75=c.height*0.75|0,
player= {
	hover_x: 0, // position geographique du pointeur en seconde
	son_geox: 0, // timecode du lecteur temporaire en seconde
	son_dur: 2, // duree de lecture du temporaire en seconde
	ptr_cnt: 0,
	audio_oqp: 0,
	auto_seek: 0,
},
config={ // TODO config modifiable
	colors:{
		wave1: "#a26",
		wave2: "#078"
	},
	zoom:{
		power: 1.8
	}
}

keyboard={}, ctx1=c.getContext("2d"), ctx2=d.getContext("2d");



/*

TODO test: normaliser le son et virer le bug 0204 "/tech dance/David Guetta - In love is myself (bug a 0204).mp3"

*/



// _menu_ | tiny_functions
let sec_to_px= sec=> Math.floor( (sec-start/sr)*(sr/zoom_x) );

let sec_to_pcm= sec=> Math.max( 0, Math.min( Math.floor( sec*sr )+1, awb.length ) );

let to2= num=> num<10?"0"+num:num;

let sec_to_minsec= sec=> to2(sec/60|0) +":"+ to2(sec%60|0) +( (sec%1).toFixed(5).replace(/^\-*0/,"").replace(/^(\.\d\d\d)/,"$1 ") );

let isNumber= val=> !isNaN(parseFloat(val)) && isFinite(val);

let _def_sel1_by_hover= _=>{   selectors.sel1= player.hover_x;   player.son_geox= selectors.sel1;   _sel("[title='Selecteur1'] .value").innerHTML= sec_to_minsec(selectors.sel1);   };



// _menu_ | e_add_dura_empty
_sel('#btn_add_dura_empty').addEventListener('click', _=>{

	let t_dur= sec_to_pcm( selectors.sel2==null ? 1 : selectors.sel2-selectors.sel1 );
	let t_at= sec_to_pcm(selectors.sel1);
	let t_data;

	let new_buf= aa.createBuffer(awb.numberOfChannels, awb.length + t_dur, sr);

	// canal 0
	t_data= new_buf.getChannelData(0);
	t_data.set(awb.getChannelData(0).subarray(0, t_at), 0); // old part 1
	t_data.set(new Float32Array(t_dur), t_at); // new part
	t_data.set(awb.getChannelData(0).subarray(t_at), t_at + t_dur); // old part 2

	// canal 1
	if( awb.numberOfChannels>1 ){
		t_data= new_buf.getChannelData(1);
		t_data.set(awb.getChannelData(1).subarray(0, t_at), 0); // old part 1
		t_data.set(new Float32Array(t_dur), t_at); // new part
		t_data.set(awb.getChannelData(1).subarray(t_at), t_at + t_dur); // old part 2
	}
	awb= new_buf;
	redraw_onde();
});



// _menu_ | e_volume
let f_volume= _=>{

	if( selectors.sel2==null ){ return; }

	let vol_1= prompt("Multiplicateur de volume pour le début (0 à 6M)",4);
	if( !isNumber(vol_1) || vol_1<0 ){ vol_1= null; }
	if( vol_1==null ){ return; }
	vol_1= Math.min(vol_1,67108864);

	let vol_2= prompt("Multiplicateur de volume pour la fin (0 à 6M)",vol_1);
	if( !isNumber(vol_2) || vol_2<0 ){ vol_2= null; }
	if( vol_2==null ){ return; }
	vol_2= Math.min(vol_2,67108864);

	vol_2= vol_2-vol_1; // vol_2 devient un offset

	let m_debut= sec_to_pcm(selectors.sel1);
	let t_cur= m_debut;
	let t_max= sec_to_pcm(selectors.sel2)+1;
	let m_offset= t_max-m_debut;
	let can0= awb.getChannelData(0);
	let can1= awb.getChannelData(1);
	let tmp_v= 0.0;
	while( t_cur<t_max ){
		tmp_v= vol_1+vol_2*(t_cur-m_debut)/m_offset;
		can0[t_cur]= Math.max(-1,Math.min(can0[t_cur]*tmp_v,1));
		can1[t_cur]= Math.max(-1,Math.min(can1[t_cur]*tmp_v,1));
		t_cur++;
	}
	redraw_onde();
};



// _menu_ | e_analyse_freq
let f_analyse_freq= _=>{

	console.info("ok");
};



// _menu_ | e_del_zone
let f_remove= _=>{

	if( selectors.sel2==null || awb.length < 2 ){
		alert("il faut selectionner une zone");
		return;
	}

	let del_duration= sec_to_pcm( selectors.sel2-selectors.sel1 );
	let del_at= sec_to_pcm(selectors.sel1);

	if( del_at >= awb.length ){
		console.info("curseur hors limite");
		return;
	}

	if( del_at + del_duration >= awb.length ){ // adapter selon demande utilisateur
		del_duration= awb.length - del_at;
	}

	if( del_duration <= 0 ){
		console.info("durée trop courte");
		return;
	}
	if( del_duration == awb.length ){
		del_duration-= 1;
	}
	// TODO degager si stable
	console.info("awb",awb.length);
	console.info("del_at",del_at);
	console.info("del_duration",del_duration);

	let t_data;

	let new_buf= aa.createBuffer(awb.numberOfChannels, awb.length - del_duration, sr);

	// canal 0
	t_data= new_buf.getChannelData(0);
	t_data.set(awb.getChannelData(0).subarray(0, del_at), 0); // old part 1
	t_data.set(awb.getChannelData(0).subarray(del_at + del_duration), del_at); // old part 2

	// canal 1
	if( awb.numberOfChannels>1 ){
		t_data= new_buf.getChannelData(1);
		t_data.set(awb.getChannelData(1).subarray(0, del_at), 0); // old part 1
		t_data.set(awb.getChannelData(1).subarray(del_at + del_duration), del_at); // old part 2
	}
	awb= new_buf;
	redraw_onde();
};



// _menu_ | o_selectors
let selectors= {

	sel1: 0, // position selecteur reel 1 en seconde

	sel2: null, // position selecteur reel 2 en seconde

	home: _=>{

		player.hover_x= -0.0000002; // besoin d'un nombre légèrement negatif sec pour coller avant pixel (car selection parfaite)
		mouse_down();
		set_zoom_et_position(zoom_x,0);
	},

	end: _=>{

		player.hover_x= awb.length/sr-0.000023;
		mouse_down();
		set_zoom_et_position(zoom_x,awb.length-zoom_x*w);
	},

	all: _=>{

		player.hover_x= -0.0000002; // besoin d'un nombre légèrement negatif sec pour coller avant pixel (car selection parfaite)
		_def_sel1_by_hover();
		selectors.sel2= awb.length/sr-0.000013;
		_sel("[title='Selecteur2'] .value").innerHTML= sec_to_minsec(selectors.sel2);
		redraw_overlay();
	}
};



// _menu_ | o_clipboard
let clipboard={

	buffer: null,

	dur: 0, // sec

	reset: _=>{

		if( selectors.sel2==null ){
			alert("selection vide");
		}
		let at= sec_to_pcm(selectors.sel1);
		let t_data;

		clipboard.dur= sec_to_pcm( selectors.sel2-selectors.sel1 );

		clipboard.buffer= aa.createBuffer(awb.numberOfChannels, clipboard.dur, sr);

		t_data= clipboard.buffer.getChannelData(0);
		t_data.set(awb.getChannelData(0).subarray(at, at + clipboard.dur), 0); // old part

		t_data= clipboard.buffer.getChannelData(1);
		t_data.set(awb.getChannelData(1).subarray(at, at + clipboard.dur), 0); // old part
	},

	paste: _=>{

		let t_data;

		let new_buf= aa.createBuffer(awb.numberOfChannels, awb.length + clipboard.dur, sr);
		let at= sec_to_pcm(selectors.sel1);

		// canal 0
		t_data= new_buf.getChannelData(0);
		t_data.set(awb.getChannelData(0).subarray(0, at), 0); // old part 1
		t_data.set(clipboard.buffer.getChannelData(0), at); // new part
		t_data.set(awb.getChannelData(0).subarray(at), at + clipboard.dur); // old part 2

		// canal 1
		if( awb.numberOfChannels>1 ){
			t_data= new_buf.getChannelData(1);
			t_data.set(awb.getChannelData(1).subarray(0, at), 0); // old part 1
			t_data.set(clipboard.buffer.getChannelData(1), at); // new part
			t_data.set(awb.getChannelData(1).subarray(at), at + clipboard.dur); // old part 2
		}

		t_data= null;
		awb= new_buf;
		new_buf= null;
		redraw_onde();

	}
};



// _menu_ | d_redraw_onde
let redraw_onde= _=>{

	if( !awb ){ return; }
	ctx1.clearRect(0,0,w,h);

	_sel("#infos").innerHTML= "de "+ start +" ("+ sec_to_minsec( start/sr ) +" s à "+ sec_to_minsec( (start+zoom_x*w)/sr ) +" s) x "+( zoom_x|0 );

	draw_spectrum_moy( zoom_x>128, 0, config.colors.wave1 );
	draw_spectrum_moy( zoom_x>128, 1, config.colors.wave2 );
};



// _menu_ | d_redraw_overlay
let redraw_overlay= _=>{

	ctx2.clearRect(0,0,w,h);
	let x1, x2;

	x1= sec_to_px(player.hover_x);
	ctx2.strokeStyle="#05ab";
	ctx2.beginPath();
	ctx2.moveTo(x1,0);
	ctx2.lineTo(x1,h);
	ctx2.stroke();

	x1= sec_to_px(selectors.sel1);
	ctx2.strokeStyle="#08f5";
	ctx2.beginPath();
	ctx2.moveTo(x1,0);
	ctx2.lineTo(x1,h);
	ctx2.stroke();

	if( clipboard.at!=null ){

		x1= sec_to_px(clipboard.at);
		x2= sec_to_px(clipboard.at + clipboard.dur);

		ctx2.fillStyle="#f402";

		ctx2.fillRect(x1, 0, x2-x1, h);
	}

	if( selectors.sel2!=null ){

		x1= sec_to_px(selectors.sel1);
		x2= sec_to_px(selectors.sel2);

		ctx2.fillStyle="#f402";

		ctx2.fillRect(x1, 0, x2-x1, h);
	}

	if( g_src ){

		x1= sec_to_px(player.son_geox);
		x2= sec_to_px(player.son_geox+player.son_dur);

		ctx2.fillStyle="#ff02";

		ctx2.fillRect(x1, 0, x2-x1, h);
	}
};



// _menu_ | d_draw_spectrum_moy
let draw_spectrum_moy= ( offsx, ch, strokeColor )=>{

	let bascu= 0;
	ctx1.strokeStyle= strokeColor;
	ctx1.fillStyle= "#fff";
	ctx1.strokeWeight= "2px";
	ctx1.beginPath();
	ctx1.moveTo( 0, h25+(ch*h50) );
	let dataz= awb.getChannelData(ch);
	for( let tk=0; tk<w; tk++ ){

		if( offsx ){
			let l= Math.round( start+tk*zoom_x );
			if( l>=dataz.length ){ tk=w; continue; };   let m= Math.abs(dataz[l]);
			if( l+1*128>=dataz.length ){ tk=w; continue; }; m= Math.max(m,Math.abs(dataz[l+1*128]));
			if( l+2*128>=dataz.length ){ tk=w; continue; }; m= Math.max(m,Math.abs(dataz[l+2*128]));
			if( l+3*128>=dataz.length ){ tk=w; continue; }; m= Math.max(m,Math.abs(dataz[l+3*128]));
			if( l+4*128>=dataz.length ){ tk=w; continue; }; m= Math.max(m,Math.abs(dataz[l+4*128]));
			if( l+5*128>=dataz.length ){ tk=w; continue; }; m= Math.max(m,Math.abs(dataz[l+5*128]));
			if( l+6*128>=dataz.length ){ tk=w; continue; }; m= Math.max(m,Math.abs(dataz[l+6*128]));
			if( l+7*128>=dataz.length ){ tk=w; continue; }; m= Math.max(m,Math.abs(dataz[l+7*128]));
			ctx1.lineTo( tk, h25+(ch*h50)+((bascu?-m:m)*h50*zoom_y) );
			bascu= 1-bascu;
		}else{
			let l= Math.round( start+tk*zoom_x );
			if( l>=dataz.length )continue;
			m= dataz[l];
			ctx1.lineTo( tk, h25+(ch*h50)+(m*h50*zoom_y) );
		}

	}
	ctx1.stroke();
};



// _menu_ | u_mouse_move
function mouse_move(event){

	if(!awb){return;}
	player.hover_x= Math.max(0,Math.min(awb.duration, (zoom_x/sr)*(start/zoom_x+event.layerX) )); // à taton, et ça a marché
	_sel("[title='Curseur'] .value").innerHTML= sec_to_minsec(player.hover_x);

	redraw_overlay();
	drawSpectrum();
}



let maybe_spectrum= _=>{
	requestAnimationFrame(maybe_spectrum);

	if( !g_src ){ return; }

	if( player.auto_seek!=0 && Date.now()-player.auto_seek>=1000 ){
		player.auto_seek+= (Date.now()-player.auto_seek);
		press_key({type:"keydown",key:"ArrowRight"});press_key({type:"keyup",key:"ArrowRight"});
	}
	let pos_ptet_sec= g_src.startat + (Date.now()-g_src.startnow)/1000; // je suppute que le player se trouve ici
	redraw_overlay();
	drawSpectrum( pos_ptet_sec );
};



// _menu_ | u_mouse_down
function mouse_down(){

	if( keyboard["Shift"] ){
		if( player.hover_x<selectors.sel1 ){ // inversion
			selectors.sel2= selectors.sel1;
			_def_sel1_by_hover();
		}else{
			selectors.sel2= player.hover_x;
		}
		_sel("[title='Selecteur2'] .value").innerHTML= sec_to_minsec(selectors.sel2);
		redraw_overlay();
		return;
	}
	_def_sel1_by_hover();
	selectors.sel2= null;
	_sel("[title='Selecteur2'] .value").innerHTML= '';
	redraw_overlay();
	if( g_src ){ direct_play(0); direct_play(0); } // switch off music
}



// _menu_ | u_mouse_scroll
function mouse_scroll(event) {

	let mx= event.layerX/2|0;
	event.preventDefault();
	let dezoom= config.zoom.power;
	let offs_2= dezoom*2-2;
	let mult_zoom= 0.9/dezoom;
	let offs_1= (1-mult_zoom)*2;

	// cool, if event.deltaY == 0, redraw juste.
	if(event.deltaY<0){
		// zoom
		start+= Math.round( mx*zoom_x*offs_1 );
		zoom_x= Math.max(0.03,zoom_x*mult_zoom); // +precis
	}else if(event.deltaY>0){
		// dezoom
		start= Math.max( 0, Math.round(start-mx*zoom_x*offs_2) );
		zoom_x= Math.min(600000,zoom_x*dezoom); // +elargi
	}
	redraw_onde();
	redraw_overlay();
}



// _menu_ | u_press_key
function press_key(event){

	if( event.type=="keyup" ){
		keyboard[event.key]= false;
		return;
	}

	if( event.type=="keydown" && !keyboard[event.key] ){
		keyboard[event.key]= true;

		if( event.key=="c" ){
			if( keyboard["Control"] ){
				clipboard.reset();
			}
			return;
		}

		if( event.key=="v" ){
			if( keyboard["Control"] ){
				clipboard.paste();
			}
			return;
		}

		if( event.key=="a" ){ // code=KeyQ... key=a
			if( keyboard["Control"] ){
				selectors.all();
			}
			return;
		}

		if( event.key==" " ){
			direct_play(1);
			return;
		}

		if( event.key=="Delete" ){
			f_remove();
			return;
		}

		if( event.key=="Home" ){
			selectors.home();
			return;
		}

		if( event.key=="End" ){
			selectors.end();
			return;
		}

		if( event.key=="ArrowLeft" ){ // TODO warn, quand je spam a mort les touches et que ça play, bah au bout d'un moment y'a saturation gestion pendant qq secondes
			if(!awb){return;}
			player.son_geox= Math.max( 0, player.son_geox-1 );
			if( g_src ){ direct_play(0); } // switch off music
			direct_play(0);
			return;
		}

		if( event.key=="ArrowRight" ){
			if(!awb){return;}
			player.son_geox= Math.min( awb.duration, player.son_geox+1 );
			if( g_src ){ direct_play(0); } // switch off music
			direct_play(0);
			return;
		}

		console.info(event.key);
	}
}



// _menu_ | v_load_a_file
_sel("#f").onchange= e=>{

	if( meta_in.name && !confirm("oublier la modification en cours?") ){
		return;
	}

	let file=e.target.files[0];
	if( !file ){ return; }
	meta_in= {
		name: file.name,
		size: file.size,
		type: file.type,
		lastModified: file.lastModified,
	};

	_sel("[title='Titre'] .value").innerHTML= meta_in.name;

	let r=new FileReader();
	r.onload=async e=>{

		if(!aa)aa= new AudioContext();
		awb= await aa.decodeAudioData( e.target.result );
		sr= awb.sampleRate; // 48000
		if( awb.numberOfChannels<1 || awb.numberOfChannels>2 ){
			alert("le nombre de canaux ("+ awb.numberOfChannels +") va poser probleme lors des traitements");
		}
		redraw_onde();
		mouse_move({layerX:0});
		_sel('#import_file').blur(); // éviter d'ouvrir encore, au press space
		_sel("[title='Longueur'] .value").innerHTML= sec_to_minsec(awb.length/sr);
		_sel("[title='Canaux'] .value").innerHTML= (vv=>vv<1?'0':vv<2?'Mono':vv<3?'Stereo':'Multi')(awb.numberOfChannels);

		set_zoom_et_position(awb.length/sr*30,0); // reset position et zoom selon taille fichier
		selectors.home();
		drawSpectrum();
	};
	r.readAsArrayBuffer(file);
};
















/**
 * Dessine le spectre de fréquences d'un AudioBuffer dans un canvas.
 */
// _menu_ | d_drawSpectrum
let drawSpectrum= (hover=player.hover_x)=>{
    // Taille de la FFT (puissance de 2 pour simplifier)
    const FFT_SIZE= 256; // fournier transformation
	let numBins= (FFT_SIZE>>1)+1;
	let div_2_ftt= 2 / FFT_SIZE;

    // Récupérer les données du premier canal (mono)
    const channelData= awb.getChannelData(0);

    // Calcul de la DFT (nombres complexe) – version naïve mais suffisante
    const real= new Float32Array(numBins);
    const imag= new Float32Array(numBins);
	let posx= sec_to_pcm(hover);
	let sumReal = 0.0;
	let sumImag = 0.0;
	let pre_angle = 0.0;
    for( let k= 0; k < numBins; k++ ){
		sumReal= 0;
		sumImag= 0;
        pre_angle= div_2_ftt * Math.PI * k;
        for( let n= 0; n < FFT_SIZE; n++ ){
            sumReal += channelData[posx+n] * Math.cos(pre_angle * n);
            sumImag -= channelData[posx+n] * Math.sin(pre_angle * n); // signe conventionnel
        }
        real[k]= sumReal;
        imag[k]= sumImag;
    }

	// Dessiner les barres verticales (spectre)
    for (let k= 0; k < numBins; k++) {
		colo_by_amp( k, 9+Math.log2( 0.001 + real[k] * real[k] + imag[k] * imag[k]) );
    }
};



// _menu_ | d_colo_by_amp
let colo_by_amp= (k,amp)=> {
	/*if( amp<0.2 ){
			ctx2.fillStyle= '#2c2'; // vert fluo
			ctx2.fillRect( (5+k)*3, 5, 3, 1 + amp*100 );
		return;
	}*/
    ctx2.fillStyle= '#4a4'; // vert fluo
	ctx2.fillRect( (5+k)*3, 2, 2, amp*5 );
};



// _menu_ | v_play_now
let direct_play= by_space=>{

	// cette fonction declenche un mini lecteur de quelques secondes car ptin c'est horrible de faire un lecteur sympa

	if( !awb ){ return; }
	if( g_src ){   delete_preview_audio(null,g_src,by_space);   return;   }

	let src= aa.createBufferSource();
	src.ptr_cnt= player.ptr_cnt;
	src.startnow= Date.now();
	if( by_space ){   player.auto_seek= src.startnow;   }
	src.startat= player.son_geox+0.00000169;
	player.ptr_cnt++;

	let playerBuf= aa.createBuffer(awb.numberOfChannels, awb.length, awb.sampleRate);
	for( let ch=0; ch<awb.numberOfChannels; ch++ ){ playerBuf.getChannelData(ch).set(awb.getChannelData(ch)); }

	src.buffer= playerBuf; // importe le buffer Modifié
	src.connect(aa.destination);
	// TODO au lieu d'injecter tout un canal, et de seek pour lire, lez go injecter juste ce qu'on prévoit de lire (genre 2 secondes de datas) et multicanaux
	src.start( 0, src.startat ); // play by position (mais impossible de recup la position en cours) + 0.00000169 pour offset perfect
	g_src= src;   redraw_overlay();
	_sel("[title='Lecteur'] .value").innerHTML= sec_to_minsec(player.son_geox);
	setTimeout(_=>{ delete_preview_audio(null,src); }, player.son_dur*1000 );

};



// _menu_ | v_del_mem_player
let delete_preview_audio= (osef,qui,by_space)=>{

	qui &&( qui.stop(),   g_src!=null && qui.ptr_cnt==g_src.ptr_cnt? g_src= null: 0,   qui= null );
	if( by_space ){   player.auto_seek= 0;   }
	_sel("[title='Lecteur'] .value").innerHTML= sec_to_minsec(player.son_geox);
	redraw_overlay();
};



_sel('#playBtn').addEventListener('click', _=>{
	press_key({type:"keydown",key:" "});press_key({type:"keyup",key:" "});
});
_sel('#stopBtn').addEventListener('click', _=>{
	if( g_src ){ direct_play(0); } // switch off music
});
_sel('#rwBtn').addEventListener('click', _=>{
	press_key({type:"keydown",key:"ArrowLeft"});press_key({type:"keyup",key:"ArrowLeft"});
});
_sel('#ffBtn').addEventListener('click', _=>{
	press_key({type:"keydown",key:"ArrowRight"});press_key({type:"keyup",key:"ArrowRight"});
});



// _menu_ | v_import
_sel('#import_file').addEventListener('click', _=>{
	_sel('#f').click();
});



// _menu_ | v_export
_sel('#exportWav').addEventListener('click', _=>{

	if( !confirm("save lourd?") || !awb ){ return; }

	// export WAV 16-bit interleaved
	let wavBlob= audioBufferToWavBlob(awb);
	let url= URL.createObjectURL(wavBlob);
	let ta= document.createElement('a');
	ta.href= url;
	ta.download= meta_in.name +" _ "+ (Date.now()/1000|0) +".wav";
	ta.click();
	URL.revokeObjectURL(url);
});



_sel('#exportLent').addEventListener('click', _=>{

	let forma= "webm";
	if(confirm("le format de sortie sera .webm, mais on peut essayer en .ogg ?")){
		forma= "ogg";
	}
	let bps= prompt("attention, save lente. Quelle qualité de sortie? (5000, 7000, 12000 ou 16000 32000 64000)",16000);
	if( bps==null ){ return; }
	if( !isNumber(bps) ){ bps= 16000; }
	bps= Math.max(5000,Math.min(64000,bps));
	console.info("compression bps: "+bps);

	const audioCtx= new AudioContext();
	const destination= audioCtx.createMediaStreamDestination();
	const lecteur= audioCtx.createBufferSource();
	lecteur.buffer= awb; // ptr, flux final après mixage
	lecteur.connect(destination);
	lecteur.start(0);

	// 2000(0.9ko/s 5khz) | 9000(1.4ko/s 6khz) , 12000(1.7ko/s 9khz) , 14000(2.2ko/s 20khz), 16000(2.4ko/s 20khz) 32000(4.3ko/s 20khz)
	const mediaRecorder= new MediaRecorder(destination.stream, { mimeType: 'audio/'+forma+'; codecs=opus', audioBitsPerSecond: bps }); // très compressé

	let recordedChunks= []; // stockage de Blob (nouvelles data audio compressés)

	mediaRecorder.ondataavailable= event=>{ if( event.data.size>0 ){ recordedChunks.push(event.data); } };

	mediaRecorder.onstop= _=>{
		let lien=document.createElement('a');
		lien.href= URL.createObjectURL( new Blob(recordedChunks, { type: "audio/webm" }) ); // url by blob datas
		lien.download= meta_in.name +" _ "+ Date.now() +".webm"; // nom du fichier
		lien.click();
		// nettouyage de la ram :
		lien= null;
		recordedChunks= [];
		// todo: deconnexion des destination et lecteur puis suppression
	};

	lecteur.onended= _=>{ mediaRecorder.stop(); }; // arreter l'enregistrement lorsque lecteur fini

	mediaRecorder.start(); // lancer le processus d'enregistrement
});




// _menu_ | v_conv_to_wav
function audioBufferToWavBlob(buffer){
	// garder car ultra utile
	// WAV conversion function (PCM16)
	let numChannels= buffer.numberOfChannels;
	let sampleRate= buffer.sampleRate;
	let format= 1; // PCM
	let bitsPerSample= 16;
	let numSamples= buffer.length;
	let blockAlign= numChannels * bitsPerSample / 8;
	let byteRate= sampleRate * blockAlign;
	let dataSize= numSamples * blockAlign;
	let bufferLen= 44 + dataSize;
	let ab= new ArrayBuffer(bufferLen);
	let view= new DataView(ab);
	/* RIFF header */
	writeString(view, 0, 'RIFF'); // ChunkID
	view.setUint32(4, 36 + dataSize, true); // ChunkSize
	writeString(view, 8, 'WAVE'); // Format
	writeString(view, 12, 'fmt '); // Subchunk1ID
	view.setUint32(16, 16, true); // Subchunk1Size
	view.setUint16(20, format, true); // AudioFormat
	view.setUint16(22, numChannels, true); // NumChannels
	view.setUint32(24, sampleRate, true); // SampleRate
	view.setUint32(28, byteRate, true); // ByteRate
	view.setUint16(32, blockAlign, true); // BlockAlign
	view.setUint16(34, bitsPerSample, true); // BitsPerSample
	writeString(view, 36, 'data'); // Subchunk2ID
	view.setUint32(40, dataSize, true); // Subchunk2Size
	// write PCM samples
	let offset= 44;
	let channelData= [];
	for( let c=0;c<numChannels;c++ ){ channelData.push(buffer.getChannelData(c)); }
	for( let i=0;i<numSamples;i++ ){
		for( let c=0;c<numChannels;c++ ){
			let sample= channelData[c][i];
			// clamp
			sample= Math.max(-1, Math.min(1, sample));
			// convert to 16-bit signed
			let s= sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
			view.setInt16(offset, Math.round(s), true);
			offset += 2;
		}
	}
	return new Blob([ab], { type: 'audio/wav' });
}



// _menu_ | v_create_wav_header
function writeString(view, offset, str) {

	for( let i=0;i<str.length;i++ ){ view.setUint8(offset + i, str.charCodeAt(i)); }
}



let set_zoom_et_position= ( zoom=0.02, pos=sr*7.9993 )=>{

	zoom_x= zoom; // px
	start= pos; // px
	mouse_scroll({ deltaY: 0, layerX: 0, preventDefault: _=>{} })
};



let init= _=>{

	maybe_spectrum();
};

// normalisation de toute la zone
// lez go compresseur
// auto nettoy (tout juste 200ms de son très faible au début, max 0.1 sec de très faible à la fin, volume normalisé)
// pouvoir ctrl z selon un histo (8 obligé + math log 2) :D donc 60 max surement et ajouter intercalaire pour changement de position des curseurs
// limiter position visuelle de fin, pas hors écran quoi
// touche pour reset zoom x y total
// faire un script qui detek les bugs, genre olala y'a du son ça bouge et d'un coup vide   ou   y'a des frequences, et d'un coup un tic
// joli curseur ?
// coller avec merge

// fleme ctrl x

// _menu_ | end_of_functions

d.onwheel= mouse_scroll;

d.addEventListener('mousemove',mouse_move,0);

d.addEventListener('mousedown',mouse_down,0);

document.addEventListener('keydown',press_key,0);

document.addEventListener('keyup',press_key,0);

window.addEventListener('load',init,0);

_sel('#btn_volume').addEventListener('click',f_volume,0);

_sel('#btn_analyse_freq').addEventListener('click',f_analyse_freq,0);

</script>
</body></html>
